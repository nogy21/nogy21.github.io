---
layouts: post

title: "DB&JDBC(06) - 서브쿼리 - 수업 28일차"

date: 2021-09-07

toc: true

toc_sticky: true

categories:

   # - database

tags:

  - "database", "java", "수업 복습"
---

오전에는 `subquery`연습을 했고 오후에는 미니 프로젝트를 진행했는데 과정이 길어서 미니 프로젝트는 다음 글에서 소개해 드리도록 하겠습니다.<br>


오늘은 예제를 통한 `subquery`연습을 짧게 보여드리려 합니다.<br>


- [Subquery 예제](#subquery-예제)
  - [SQL 테스트](#sql-테스트)
  - []()

<p align="center"><img src="https://user-images.githubusercontent.com/70495425/131687801-2b295fb7-6e22-4e70-a1ef-a7dc85b96796.png" alt="sun cloud" height="10%" width="10%" /></p>



<details>
	<summary>복습 키워드<br></summary>
	<div markdown="1">stack | heap | start() | run() | Thread | Synchronized | DBMS | SQL | Middleware | jdbc | DML | CRUD | DDL | DCL | Transaction | con.setAutoCommit() | rollback() | throw | </div>
</details>



---
_참고사항(강사님께서 수업 중 조언해주셨던 사항들입니다.)_

> _DB와 연결이 끊겼을 경우
> : ping 확인(이상 있을 시 계속 진행) 
> -> 윈도우에서 서비스 실행 
> -> OracleServiceXE, OracleServiceXETNSListener 실행_
>
> _데이터를 직접 신속하게 수정하고 싶을 경우 _
> _-> Data Source Explorer -> Oracle _
> _-> xe -> Schemas -> username _
> _-> Tables에서 수정_		(공부하는 입장에서 직접 수정은 권장하지 않음)
>
> _test 코드를 작성해서 단위 테스트를 진행하는 연습이 중요!_
>





### Subquery 예제

이제 본격적으로 수업 내용을 복습하도록 하겠습니다.

`Employee` 테이블을 만들어서 사원번호, 이름, 부서, 월급의 컬럼을 생성했습니다.

여기서 `subquery`연습을 위해 특정 `job`(부서)의 사원 중 가장 높은 `salary`를 받는 사원 정보를 조회하는 메서드를 만드는 것이 목적입니다.



#### SQL 테스트

먼저 SQL파일을 생성해서 간단한 단위 테스트를 해보겠습니다.

다음과 같이 진행합니다.

2. model 패키지 내에 Employee 클래스 파일 생성 
   -> 인스턴스 변수 생성 
   -> 생성자: 1. 기본(단일 등록); 2. 사원번호 제외(insert); 3. 전부(조회)
   -> getter setter -> toString()
3. model 패키지 내에 DbInfo interface 생성
   -> `DRIVER`, `URL`, `ID`, `PASSWORD`를 static final 상수로 생성(인터페이스이므로 field(변수+상수)는 public static final로 인식된다)
4. model 패키지 내에 EmployeeDAO 생성
   -> `드라이버 로딩` -> `closeAll() 메서드 생성, 오버라이딩`

---

3교시

1. test 패키지 생성, TestEmployeeDAO1 클래스 생성

2. register() 메서드를 만들어서 데이터를 저장

3. 해당 job(부서)의 사원 중 가장 높은 salary를 받는 사원 정보를 조회하는 메서드 생성

   3-1. sql 단위 테스트 진행(`subquery` 사용)

   ​	3-1-1. job에 해당하는 사원의 가장 높은 salary를 조회

   ​	: `SELECT MAX(salary) FROM s_employee WHERE job='개발';`

   ​	3-1-2.위 sql에서 조회된 salary를 받는 사원 정보(job에 해당하는 사원에 한함)

   ​	: `SELECT empno, name, job, salary FROM s_employee WHERE job='개발' AND salary=(3-1-1의 sql문)`

   3-2. `ArrayList<Employee>` 타입의 `list`를 생성하고 sql문을 활용하여 데이터를 `list`에 할당합니다.

---

4교시

 이번 예제를 연습하는데 있어서 핵심 내용은 `subquery`의 활용입니다. 하루 전 수업에서 `subquery`를 배웠고 간단한 `sql`문으로 작성을 해봤는데 이를 `java` 프로그램으로 구현하는 부분이기에 보다 자세히 분석해보도록 하겠습니다.<br>

위의 3번 단계를 보시면 sql 단위테스트를 다시 두 번의 단계로 나누어서 진행을 하게 됩니다.<br>

핵심은 `job='개발'`인 `WHERE`절을 두 번 사용해야 한다는 부분입니다. 단순하게 생각했을 경우 가장 높은 `salary`를 받는 `job ='개발'`인 사원 정보를 조회해야 하기에 `MAX(salary)`를 조회하는 단계에서 `WHERE job='개발'` 부분을 빠뜨리기 쉽습니다. 이 경우 다른 부서의 `salary`가 더 높을 때 저희가 원하는 정보를 조회할 수 없게 됩니다. 예를 들어 #?#?

`SELECT * FROM s_employee WHERE job ='개발' AND salary = (SELECT max(salary) FROM s_employee WHERE job = '개발');`

```java
public ArrayList<Employee> getEmployeeListByHighSalAndJob(String job) throws SQLException {
    ArrayList<Employee> list = new ArrayList<Employee>();
    Connection con = null;
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    try {
        con = DriverManager.getConnection(DbInfo.URL, DbInfo.USERNAME, DbInfo.PASSWORD);
        StringBuilder sql = new StringBuilder("SELECT empno, name, job, salary "); 
        sql.append("FROM s_employee ");
        sql.append("WHERE job = ? ");
        sql.append("AND salary = (SELECT max(salary) FROM s_employee WHERE job = ?");
        pstmt = con.prepareStatement(sql.toString());
        pstmt.setString(1, job);
        pstmt.setString(2, job);
        rs = pstmt.executeQuery();
        while(rs.next()) {
            list.add(new Employee(rs.getString(1),rs.getString(2),rs.getString(3),rs.getInt(4)));
        }
    } finally {
        closeAll(rs, pstmt, con);
    }
    return list;
}
```





<p align="center"><img src="https://user-images.githubusercontent.com/70495425/131689647-b4d2206e-7ec4-4f7f-a734-6c3bf77c80c3.png" height="10%" width="10%"></p>

