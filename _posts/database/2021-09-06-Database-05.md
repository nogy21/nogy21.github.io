---
layouts: post

title: "DB&JDBC(05) - 트랜잭션&서브쿼리 - 수업 27일차"

date: 2021-09-06

toc: true

toc_sticky: true

categories:

  # - database

tags:

  # - "database", "java", "수업 복습"

---



<p align="center"><img src="https://user-images.githubusercontent.com/70495425/131687801-2b295fb7-6e22-4e70-a1ef-a7dc85b96796.png" alt="sun cloud" height="10%" width="10%" /></p>

1교시

![image](https://user-images.githubusercontent.com/70495425/132145697-1f664418-f4e2-4a4d-9df3-ec0278cf4281.png)

<img src="C:\Users\Yong Lee\AppData\Roaming\Typora\typora-user-images\image-20210906092859555.png" alt="image-20210906092859555" style="zoom:67%;" />

<details>
	<summary>복습 키워드<br>
	</summary>
	<div markdown="1">
        javaSE(Standard Edition) / javaEE(Enterprise Edition) | jdk | compiler | jre | jvm | interpreter | gc | heap | local variable | stack | 자료구조 | Queue | static | metaspace | 객체지향 | inheritance | encaptulation | polymorphism | template method design pattern | abstract | interface | Collection | 객체 직렬화 | Stream | Thread | synchronized | extends Thread | implements Runnable | java.lang.Object | socket | String, StringBuilder, StringBuffer(thread safe) | sql | jdbc | DML | DDL | DCL | Driver loading | Connection | ComparedStatement | ResultSet | close | finally | order by | distinct | 
	</div>
</details>


---

2교시

sequence | 시퀀스명.nextval

실제 적용 시 시퀀스명.nextval: 다음 시퀀스 값이 반환

ex) 실제 DAO 적용 사례
    `insert into guestbook(guestbook_no, title) values(guestbook_seq.nextval, ?)`

현재 시퀀스 값을 반환 -> 시퀀스명.currval

단, currval은 시퀀스를 nextval한 세션 내에서만 사용 가능.

같은 커넥션 내에서만 사용 가능하다.(연결 시작 ~ 연결 종료 시까지 nextval한 커넥션 내에서만 currval 사용 가능)

(참고, session: 사용자가 database에 접속해서 접속 종료 시까지 유지되는 정보)

```sql
-- 시퀀스명.nextval
SELECT guestbook_seq.nextval from dual;
-- 시퀀스명.currval
SELECT guestbook_seq.currval from dual;
```

위의 sql문은 각 라인을 따로 실행할 경우 `currval`은 작동하지 않습니다. 다양한 client들이 sequence를 사용하기에 특정하지 않는다면 현재값을 알 수 없습니다. 그래서 자신이 `nextval`한 그 `curval(current value)`에 대해서만 값을 알 수 있도록 했습니다. `currval`은 단독으로 실행될 수 없고 `nextval`를 실행한 커넥션 내에서만 `currval`을 사용할 수 있기에 두 라인을 함께 영역지정해서 실행할 경우 정상적인 작동을 확인할 수 있습니다(동일한 세션 내에서만 실행 가능). 물론 `guestbook` 테이블과 `guestbook_seq`를 생성한 상태로 진행한 결과입니다.

웹 수업의 로그인 세션 등의 내용을 다룰 때 현재 내용을 숙지해두면 더 쉬울 것이다.

---

3교시

```java
public class TestGuestBookDAO3 {
    public static void main(String[] args) {
        // guestbook에 insert(guestbook_no는 sequence로 자동 발급)
        // TestGuestBookDAO1의 방명록 글 등록 기능을 업데이트
        // 글 등록을 하고나면 DB에서 발급한 글 번호가 GuestBookDTO에 할당이 되어 있도록
        // registerVer2 메서드를 구현해본다(sequence의 nextval과 함께 currval을 사용한다
        try {
            GuestBookDAO dao = new GuestBookDAO();
            GuestBookDTO dto = new GuestBookDTO("즐거운 월요일", "즐겁게 공부합시다");
            System.out.println("글 등록 이전 dto: "+dto);
            dao.registerVer2(dto);
            System.out.println("방명록에 글 등록");
            // db에서 발급한 sequence의 nextval한 값이 dto의 guestbookNo 인스턴스 변수에 할당되어 있다.
            System.out.println("글 등록 이후 dto: "+dto);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
```



```java
public void registerVer2(GuestBookDTO dto) throws SQLException {
    Connection con = null;
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    try {
        con = DriverManager.getConnection(url, username, password);
        String insertSql = "insert into guestbook(guestbook_no, title, content) values(guestbook_seq.nextval, ?, ?)";
        pstmt = con.prepareStatement(insertSql);
        pstmt.setString(1, dto.getTitle());
        pstmt.setString(2, dto.getContent());
        pstmt.executeUpdate();            
        pstmt.close();
        String selectSql = "select guestbook_seq.currval from dual";
        pstmt = con.prepareStatement(selectSql);
        rs = pstmt.executeQuery();
        if(rs.next()) {
            int guestbookNo = rs.getInt(1);//insert 시점에 발급받은 시퀀스(guestbook_no에 저장된 값)의 현재값을 받아온다
            dto.setGuestbookNo(guestbookNo);//dto에 할당한다
        }
    }finally {
        closeAll(rs, pstmt, con);
    }
}
```



Sequence -> 2가지 옵션 존재 > guestbook_seq.nextval(다음값) 

​											  또는 guestbook_seq.currval(현재값)

​														ㄴ 하나의 커넥션 내에서만 currval을 사용할 수 있다



-- `LIKE` 연산자: 일부가 포함되는 내용을 검색하는 연산자(웹의 검색 기능에서 많이 사용됨)
-- `WHERE 컬럼명 LIKE '%검색키워드%'`
-- `%`: 0개 이상의 문자

```sql
SELECT * FROM PRODUCT WHERE NAME LIKE '%면%'; 
```

-- 위 LIKE 적용 SQL을 PreparedStatement에 적용하는 방법은 아래와 같다

```java
String sql = "SELECT * FROM guestbook WHERE title LIKE '%' || ? || '%'";
```



---

4교시

```java
public class TestGuestBookDAO4 {
    public static void main(String[] args) {
        // LIKE 연산자를 이용해서 방명록 글제목(TITLE)을 이용해 정보를 조회하는 기능을 구현
        try {
            GuestBookDAO dao = new GuestBookDAO();
            String keyword = "즐";
            //keyword = "월";
            ArrayList<GuestBookDTO> list = dao.getGuestBookListLikeKeyword(keyword);
            for(int i=0; i<list.size();i++)
                System.out.println(list.get(i));
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
```



```java
public ArrayList<GuestBookDTO> getGuestBookListLikeKeyword(String keyword) throws SQLException {
    ArrayList<GuestBookDTO> list = new ArrayList<GuestBookDTO>();
    Connection con = null;
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    try {
        con = DriverManager.getConnection(url, username, password);
        String sql = "SELECT * FROM guestbook WHERE title LIKE'%'||'?'||'%'";
  		pstmt = con.prepareStatement(sql);
        pstmt.setString(1, keyword);
        rs = pstmt.executeQuery();
        while(rs.next()) {
            list.add(new GuestBookDTO(rs.getInt(1), rs.getString(2), rs.getString(3)));
            }
    }finally {
        closeAll(rs, pstmt, con);
    }
    return list;
}
```



for loop 콜론 사용

아래와 같은 방식으로도 for loop를 실행할 수 있다
for(GuestBookDTO dto:list) //  list에 있는 모든 요소를 순차적으로 dto에 할당하면서 반복한다
    System.out.println(dto); //  편리하지만 성능이 떨어질 수 있다.

---

5교시

### TRANSACTION

: 작업 단위(데이터베이스의 상태를 변경시키기 위해 수행하는 작업 단위)

`DCL` -> `COMMIT`, `ROLLBACK`

 * `COMMIT`: 변경된 작업 내용을 실제 데이터베이스에 반영(실제 저장)
 * `ROLLBACK`: 변경된 작업 내용을 취소하고 이전 상태로 되돌림



ex) 카드 발급 시 포인트 지급을 약속 -> 카드 발급 트랜잭션(카드 발급 + 포인트 지급)



카드 발급 트랜잭션

1. 카드 발급

2. 약속한 포인트 지급

   *1, 2번 두 사항이 모두 정상적으로 실행되었을 때에만 COMMIT 되어야 한다(실제 DB에 저장)

만약 트랜잭션 내부의 작업에 문제가 발생했을 경우 1. 카드 발급은 정상적으로 진행되고

​		*약속한 포인트 지급은 문제가 발생했다면 ROLLBACK되어야 한다

​		(즉, 1. 카드발급 작업 내용 또한 취소가 되어야 한다)



Application에서 트랜잭션 처리

 *      JDBC 기본 트랜잭션 설정: `Auto Commit` - True에서 수동(`Mannual Commit`) 모드로 변경
 *                               Connection의 method: `setAutoCommit(false)`

<img src="https://user-images.githubusercontent.com/70495425/132164294-ba9dd8e6-74a7-4733-afbe-b3e795022107.png" alt="image" style="zoom:80%;" />

#### COMMIT & ROLLBACK

* 트랜잭션의 기본 설정인 `Auto Commit` 모드를 수동으로 변경한 후 

 * 트랜잭션 내 모든 작업이 정상적으로 진행되었을 때  `commit()`을 실행(실제 db에 작업 내용을 반영)

   ![image](https://user-images.githubusercontent.com/70495425/132164490-a673abbe-2873-4432-b9df-30cdce6914b8.png)

 * 작업 진행 중 문제가 발생했을 때 `rollback()`을 실행(작업 내용을 취소하고 되돌린다)

   ![image](https://user-images.githubusercontent.com/70495425/132164521-caf6d08f-776c-425a-b19b-de7fb0371800.png)

예시)

```java
try{
    세부 작업 1
    세부 작업 2
    ....
    con.commit();
}catch(Exception e){
    con.rollback();
}finally{
    closeAll()
}
```



트랜잭션 -> 업무 단위.

ex) 

카드 발급

   - 카드 발급
   - 포인트 지급

계좌 이체(송금자 계좌에서 출금 & 수금자 계좌에 입금)

`Transaction ACID`(원자성, 일관성, 고립성, 지속성) -> 시험 공부 시

`Spring Transaction`

`static final`이기 때문에 `private` 제거, 대문자로 변수 세팅

---

6교시

일부러 에러 상황을 발생. 트랜잭션 처리 비교

=> 차이점: 장애 발생 시 롤백 여부

```sql
CREATE TABLE card(
    id VARCHAR2(100) PRIMARY KEY,
    name VARCHAR2(100) NOT NULL
)
CREATE TABLE point(
    id VARCHAR2(100) PRIMARY KEY,
    point_type VARCHAR2(100) NOT NULL,
    point NUMBER NOT NULL
)
SELECT * FROM card;
SELECT * FROM point;
```



---

7교시

`Transaction`처리 -> 업무 단위, 작업 단위 -> 원자성 -> 더 이상 쪼갤 수 없는 것

카드발급 -> 카드 등록 & 포인트 등록 전체가 하나의 `Transaction`

```java
try{
    con.setAutoCommit(false); // 자동 커밋 x.
    ....
    ....
    commit();//정상 수행
}catch(Exception e){
    rollback();//문제 발생 시 롤백
 	throw e;//롤백 진행 후 메인에도 에러 상황을 전파
}finally{}
```

`Transaction`처리를 제대로 하지 않을 경우 큰 문제를 야기할 수 있음

---

8교시

### SubQuery

상품 정보 중 가장 비싼 가격의 상품명?

1. 상품 최고가를 조회

```sql
SELECT max(price) FROM product;
```

2. 최고가인 2200 price를 가진 상품명을 조회

```sql
SELECT name FROM product WHERE price=2200;
```

위의 1번, 2번 sql을 subquery를 이용해 한번에 조회

```sql
SELECT name FROM product WHERE price=(SELECT max(price) FROM product);
```

> 참고) _subquery가 먼저 실행되어 최고가를 조회하고, 그 후 상품명을 조회_



전에 사용했던 `product` 테이블을 그대로 사용하여 예제를 진행하겠습니다.



전체 상품의 평균 가격보다 높은 가격의 상품들 중 가장 낮은 가격의 name, maker, price를 조회하는 예제로 `subquery`를 연습하는 예제이기에 세 단계로 나누어서 진행하겠습니다.

```sql
-- 1) 전체 상품 평균가: 1600
SELECT avg(price) FROM product;
-- 2) 상품 평균가보다 높은 가격의 상품들 중 가장 낮은 가격? 1700
SELECT min(price) FROM product WHERE price > 1600;
-- 3) 평균가보다 높은 가격의 상품들 중 가장 낮은 가격의 상품 정보 조회
SELECT name, maker, price FROM product WHERE price = 1700;

-- 1, 2, 3을 subquery를 이용해 하나의 sql로 표현해본다.
SELECT name, maker, price FROM product WHERE price = (SELECT min(price) FROM product WHERE price > (SELECT avg(price) FROM product));
```



​	



<p align="center"><img src="https://user-images.githubusercontent.com/70495425/131689647-b4d2206e-7ec4-4f7f-a734-6c3bf77c80c3.png" height="10%" width="10%"></p>

